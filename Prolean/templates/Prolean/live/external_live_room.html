{% extends 'Prolean/base.html' %}
{% load static %}

{% block title %}Live Session{% endblock %}

{% block content %}
<div class="max-w-7xl mx-auto px-3 sm:px-6 lg:px-8 py-6 sm:py-8">
    <div class="rounded-3xl border border-neutral-200 bg-gradient-to-r from-white via-orange-50 to-white p-4 sm:p-6 shadow-sm mb-4 sm:mb-6">
        <div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4">
            <div>
                <p class="text-[10px] font-black uppercase tracking-[0.2em] text-neutral-500">Live Session</p>
                <h1 class="text-lg sm:text-2xl font-black text-neutral-900 break-words">{{ room_name }}</h1>
                <p class="text-xs sm:text-sm text-neutral-600 mt-1">Role: {{ live_role|title }}</p>
            </div>
            <div class="flex items-center gap-2 sm:gap-3">
                <span id="conn-badge" class="px-3 py-1 rounded-full text-[10px] sm:text-xs font-bold uppercase tracking-wider bg-amber-100 text-amber-700">
                    Connecting
                </span>
                <form method="post" action="{% url 'Prolean:external_live_leave' session_id %}">
                    {% csrf_token %}
                    <button type="submit" class="px-3 sm:px-4 py-2 rounded-xl bg-red-600 text-white font-bold text-xs sm:text-sm hover:bg-red-700 transition-colors">
                        Leave
                    </button>
                </form>
            </div>
        </div>
    </div>

    <div id="conn-error" class="hidden mb-4 px-4 py-3 rounded-xl border border-red-200 bg-red-50 text-red-700 text-sm font-semibold"></div>

    <div class="mb-4 rounded-2xl border border-emerald-200 bg-emerald-50 p-3 sm:p-4">
        <div class="flex items-center justify-between gap-3 mb-2">
            <p class="text-[10px] font-black uppercase tracking-[0.2em] text-emerald-700">Live Activity</p>
            <span id="speaking-count" class="px-2 py-1 rounded-full bg-white text-emerald-700 text-[10px] font-black">0 Speaking</span>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div class="rounded-xl bg-white border border-emerald-100 p-3">
                <p class="text-[10px] font-black uppercase tracking-[0.15em] text-neutral-500 mb-2">Now Speaking</p>
                <div id="speaking-list" class="flex flex-wrap gap-2"></div>
            </div>
            <div class="rounded-xl bg-white border border-emerald-100 p-3">
                <p class="text-[10px] font-black uppercase tracking-[0.15em] text-neutral-500 mb-2">Raised Hands</p>
                <div id="raised-hands-list" class="flex flex-wrap gap-2"></div>
            </div>
        </div>
    </div>

    <div class="grid grid-cols-1 xl:grid-cols-4 gap-4 sm:gap-6">
        <div class="xl:col-span-3 rounded-3xl border border-neutral-200 bg-neutral-950 p-3 sm:p-4 min-h-[52vh] sm:min-h-[62vh]">
            <div id="main-stage" class="relative w-full h-[40vh] sm:h-[50vh] rounded-2xl overflow-hidden bg-black border border-neutral-800"></div>
            <div id="thumb-strip" class="mt-3 grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3"></div>
            <div id="audio-sink" class="hidden"></div>
        </div>

        <div class="rounded-3xl border border-neutral-200 bg-white p-4 sm:p-5">
            <p class="text-[10px] font-black uppercase tracking-[0.2em] text-neutral-500 mb-4">Controls</p>
            <div class="space-y-3">
                <button id="toggle-audio" class="w-full px-4 py-2.5 rounded-xl border border-neutral-300 font-bold text-sm hover:bg-neutral-50">
                    Mute Mic
                </button>
                <button id="toggle-video" class="w-full px-4 py-2.5 rounded-xl border border-neutral-300 font-bold text-sm hover:bg-neutral-50">
                    Stop Camera
                </button>
                <button id="raise-hand" class="w-full px-4 py-2.5 rounded-xl border border-neutral-300 font-bold text-sm hover:bg-neutral-50">
                    Raise Hand
                </button>
                <button id="enable-sound" class="w-full px-4 py-2.5 rounded-xl border border-neutral-300 font-bold text-sm hover:bg-neutral-50">
                    Enable Sound
                </button>
            </div>
            <p class="text-xs text-neutral-500 mt-5">Students can speak and raise hand. Student camera is disabled.</p>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
<script>
(() => {
  const rawLivekitUrl = "{{ livekit_url|escapejs }}";
  const livekitToken = "{{ livekit_token|escapejs }}";
  const isProfessor = "{{ live_role|escapejs }}" === "professor";
  const selfName = "{{ user.get_full_name|default:user.username|escapejs }}";

  const mainStage = document.getElementById("main-stage");
  const thumbStrip = document.getElementById("thumb-strip");
  const audioSink = document.getElementById("audio-sink");
  const badge = document.getElementById("conn-badge");
  const btnAudio = document.getElementById("toggle-audio");
  const btnVideo = document.getElementById("toggle-video");
  const btnRaiseHand = document.getElementById("raise-hand");
  const btnEnableSound = document.getElementById("enable-sound");
  const errBox = document.getElementById("conn-error");
  const speakingList = document.getElementById("speaking-list");
  const raisedHandsList = document.getElementById("raised-hands-list");
  const speakingCount = document.getElementById("speaking-count");

  const videoTiles = new Map();  // key -> {wrapper, media, track, isLocal, label}
  const audioEls = new Map();    // key -> element
  const raisedHands = new Map(); // identity -> name
  let mainVideoKey = null;

  const normalizeLivekitUrl = (value) => {
    const cleaned = String(value || "").trim().replace(/^['"]|['"]$/g, "");
    if (!cleaned) return "";
    if (/^wss?:\/\//i.test(cleaned)) return cleaned;
    return `wss://${cleaned}`;
  };

  const livekitUrl = normalizeLivekitUrl(rawLivekitUrl);
  if (!livekitUrl || !livekitToken) {
    badge.textContent = "Config Error";
    badge.className = "px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wider bg-red-100 text-red-700";
    if (errBox) {
      errBox.textContent = `Missing live config. URL="${rawLivekitUrl || '-'}"`;
      errBox.classList.remove("hidden");
    }
    return;
  }

  try {
    new URL(livekitUrl);
  } catch {
    badge.textContent = "Invalid URL";
    badge.className = "px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wider bg-red-100 text-red-700";
    if (errBox) {
      errBox.textContent = `Invalid LiveKit URL: "${livekitUrl}"`;
      errBox.classList.remove("hidden");
    }
    return;
  }

  const room = new LivekitClient.Room({
    adaptiveStream: true,
    dynacast: true,
    stopLocalTrackOnUnpublish: true,
  });

  const showError = (message) => {
    if (!errBox) return;
    errBox.textContent = message;
    errBox.classList.remove("hidden");
  };

  const setStatus = (label, state) => {
    badge.textContent = label;
    const classByState = {
      ok: "px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wider bg-green-100 text-green-700",
      warn: "px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wider bg-amber-100 text-amber-700",
      err: "px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wider bg-red-100 text-red-700",
    };
    badge.className = classByState[state] || classByState.warn;
  };

  const makeIdentityLabel = (identity) => {
    if (!identity) return "Participant";
    if (identity === room.localParticipant.identity) return "You";
    return identity;
  };

  const renderSpeaking = () => {
    const speakers = room.activeSpeakers || [];
    speakingList.innerHTML = "";
    if (!speakers.length) {
      speakingList.innerHTML = '<span class="px-2 py-1 rounded-full bg-neutral-100 text-neutral-500 text-xs font-bold">No one speaking</span>';
    } else {
      speakers.forEach((p) => {
        const chip = document.createElement("span");
        chip.className = "px-2 py-1 rounded-full bg-emerald-100 text-emerald-700 text-xs font-bold";
        chip.textContent = makeIdentityLabel(p.identity);
        speakingList.appendChild(chip);
      });
    }
    speakingCount.textContent = `${speakers.length} Speaking`;
  };

  const renderRaisedHands = () => {
    raisedHandsList.innerHTML = "";
    if (!raisedHands.size) {
      raisedHandsList.innerHTML = '<span class="px-2 py-1 rounded-full bg-neutral-100 text-neutral-500 text-xs font-bold">No raised hands</span>';
      return;
    }
    raisedHands.forEach((name, identity) => {
      const chip = document.createElement("span");
      chip.className = "px-2 py-1 rounded-full bg-orange-100 text-orange-700 text-xs font-bold";
      chip.textContent = `${name || identity}`;
      raisedHandsList.appendChild(chip);
    });
  };

  const createVideoWrapper = (label) => {
    const wrapper = document.createElement("div");
    wrapper.className = "relative rounded-xl overflow-hidden border border-neutral-800 bg-black";
    const footer = document.createElement("div");
    footer.className = "absolute left-2 bottom-2 px-2 py-1 rounded bg-black/70 text-white text-[11px] font-bold";
    footer.textContent = label;
    wrapper.appendChild(footer);
    return wrapper;
  };

  const setMainVideo = (key) => {
    if (!videoTiles.has(key)) return;
    if (mainVideoKey === key) return;
    mainStage.innerHTML = "";
    const tile = videoTiles.get(key);
    const cloned = document.createElement("div");
    cloned.className = "relative w-full h-full rounded-2xl overflow-hidden bg-black";
    const media = tile.track.attach();
    media.className = "w-full h-full object-cover bg-black";
    media.muted = tile.isLocal;
    media.autoplay = true;
    media.playsInline = true;
    media.setAttribute("playsinline", "true");
    cloned.appendChild(media);
    const footer = document.createElement("div");
    footer.className = "absolute left-3 bottom-3 px-3 py-1 rounded bg-black/70 text-white text-xs font-bold";
    footer.textContent = tile.label;
    cloned.appendChild(footer);
    mainStage.appendChild(cloned);
    mainVideoKey = key;
  };

  const attachVideoTrack = (track, identity) => {
    const key = `video:${track.sid || identity}`;
    if (videoTiles.has(key)) return;

    const isLocal = identity === room.localParticipant.identity;
    const label = makeIdentityLabel(identity);
    const wrapper = createVideoWrapper(label);
    const media = track.attach();
    media.className = "w-full h-28 sm:h-32 object-cover bg-black";
    media.autoplay = true;
    media.playsInline = true;
    media.muted = isLocal;

    wrapper.insertBefore(media, wrapper.firstChild);
    wrapper.addEventListener("click", () => setMainVideo(key));
    thumbStrip.appendChild(wrapper);

    videoTiles.set(key, { wrapper, media, label, isLocal, identity, track });

    if (!mainVideoKey) {
      setMainVideo(key);
    } else if (isProfessor && isLocal) {
      setMainVideo(key);
    } else if (!isProfessor && !isLocal && String(identity).startsWith("prof_")) {
      setMainVideo(key);
    }
  };

  const attachAudioTrack = (track, identity) => {
    const key = `audio:${track.sid || identity}`;
    if (audioEls.has(key)) return;

    const audioEl = track.attach();
    audioEl.autoplay = true;
    audioEl.playsInline = true;
    audioEl.muted = false;
    audioEl.dataset.key = key;
    audioSink.appendChild(audioEl);
    audioEls.set(key, audioEl);
    const playPromise = audioEl.play();
    if (playPromise && typeof playPromise.catch === "function") {
      playPromise.catch(() => setStatus("Tap Enable Sound", "warn"));
    }
  };

  const detachTrack = (track) => {
    const sid = track.sid || "";
    const videoKey = `video:${sid}`;
    const audioKey = `audio:${sid}`;

    if (videoTiles.has(videoKey)) {
      const tile = videoTiles.get(videoKey);
      tile.wrapper.remove();
      videoTiles.delete(videoKey);
      if (mainVideoKey === videoKey) {
        mainVideoKey = null;
        const next = videoTiles.keys().next();
        if (!next.done) setMainVideo(next.value);
        else mainStage.innerHTML = "";
      }
    }

    if (audioEls.has(audioKey)) {
      audioEls.get(audioKey).remove();
      audioEls.delete(audioKey);
    }

    track.detach().forEach((el) => el.remove());
  };

  const renderExistingParticipantTracks = (participant) => {
    participant.trackPublications.forEach((pub) => {
      if (!pub.track) return;
      if (pub.track.kind === "video") attachVideoTrack(pub.track, participant.identity);
      if (pub.track.kind === "audio") attachAudioTrack(pub.track, participant.identity);
    });
  };

  room
    .on(LivekitClient.RoomEvent.TrackSubscribed, (track, publication, participant) => {
      if (track.kind === "video") attachVideoTrack(track, participant.identity);
      if (track.kind === "audio") attachAudioTrack(track, participant.identity);
    })
    .on(LivekitClient.RoomEvent.TrackUnsubscribed, (track) => detachTrack(track))
    .on(LivekitClient.RoomEvent.ActiveSpeakersChanged, () => renderSpeaking())
    .on(LivekitClient.RoomEvent.Disconnected, () => setStatus("Disconnected", "err"))
    .on(LivekitClient.RoomEvent.DataReceived, (payload, participant) => {
      try {
        const message = JSON.parse(new TextDecoder().decode(payload));
        if (!message || !message.type) return;
        if (message.type === "raise_hand") {
          raisedHands.set(participant?.identity || message.name || "student", message.name || participant?.identity || "student");
          renderRaisedHands();
        }
        if (message.type === "hand_lowered") {
          raisedHands.delete(participant?.identity || "");
          renderRaisedHands();
        }
      } catch (_) {}
    });

  setStatus("Connecting", "warn");
  renderSpeaking();
  renderRaisedHands();

  room.connect(livekitUrl, livekitToken)
    .then(async () => {
      setStatus("Connected", "ok");
      room.remoteParticipants.forEach((p) => renderExistingParticipantTracks(p));

      if (isProfessor) {
        try { await room.localParticipant.setMicrophoneEnabled(true); } catch (e) { showError(`Microphone error: ${e.message || e}`); }
        try { await room.localParticipant.setCameraEnabled(true); } catch (e) { showError(`Camera error: ${e.message || e}`); }
        renderExistingParticipantTracks(room.localParticipant);
        btnVideo.disabled = false;
        btnVideo.classList.remove("opacity-50", "cursor-not-allowed");
      } else {
        try { await room.localParticipant.setCameraEnabled(false); } catch (_) {}
        try { await room.localParticipant.setMicrophoneEnabled(true); } catch (e) { showError(`Student microphone permission: ${e.message || e}`); }
        btnVideo.disabled = true;
        btnVideo.classList.add("opacity-50", "cursor-not-allowed");
        btnVideo.textContent = "Camera Disabled for Students";
      }
    })
    .catch((err) => {
      setStatus("Connection Failed", "err");
      showError(`LiveKit connection failed: ${err?.message || err}`);
    });

  btnAudio.addEventListener("click", async () => {
    try {
      const enabled = room.localParticipant.isMicrophoneEnabled;
      await room.localParticipant.setMicrophoneEnabled(!enabled);
      btnAudio.textContent = enabled ? "Unmute Mic" : "Mute Mic";
    } catch (err) {
      showError(`Mic toggle failed: ${err?.message || err}`);
    }
  });

  btnVideo.addEventListener("click", async () => {
    if (!isProfessor) return;
    try {
      const enabled = room.localParticipant.isCameraEnabled;
      await room.localParticipant.setCameraEnabled(!enabled);
      btnVideo.textContent = enabled ? "Start Camera" : "Stop Camera";
    } catch (err) {
      showError(`Camera toggle failed: ${err?.message || err}`);
    }
  });

  btnRaiseHand.addEventListener("click", async () => {
    try {
      const payload = JSON.stringify({ type: "raise_hand", name: selfName, ts: Date.now() });
      await room.localParticipant.publishData(new TextEncoder().encode(payload), { reliable: true });
      btnRaiseHand.textContent = "Hand Raised";
      setTimeout(() => { btnRaiseHand.textContent = "Raise Hand"; }, 2000);
    } catch (err) {
      showError(`Raise hand failed: ${err?.message || err}`);
    }
  });

  btnEnableSound.addEventListener("click", async () => {
    const audios = audioSink.querySelectorAll("audio");
    for (const audio of audios) {
      try {
        audio.muted = false;
        audio.volume = 1;
        await audio.play();
      } catch (_) {}
    }
    setStatus("Connected", "ok");
  });
})();
</script>
{% endblock %}
